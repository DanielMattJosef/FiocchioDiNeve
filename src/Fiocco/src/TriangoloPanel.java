import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 * É il panel sul quae viene disegnato il trangolo.
 *
 * @author Daniel Matt
 */
public class TriangoloPanel extends JPanel implements MouseListener {

    /**
     *
     */
    private Polygon poligono;

    /**
     * Rappresenta il raggio del punto del poligono di taglio.
     */
    private int radius = 3;

    /**
     * Ultima larghezza del panel.
     */
    private int lastWidth = 0;

    /**
     * Ultima altezza del panel.
     */
    private int lastHeight = 0;

    /**
     * Classe che rappresenta i poligoni di taglio.
     */
    private static PoligonoTaglio taglio = new PoligonoTaglio();

    /**
     * Classe che rappresenta il triangolo di base.
     */
    private static Triangolo triangolo = new Triangolo();

    /**
     * Classe che si occupa di salvare i punti de poligoni di taglio.
     */
    private SavePoints salva = new SavePoints();

    /**
     * Rappresenta il triangolo tagliato.
     */
    public TriangoloTagliato triangoloTagliato;

    /**
     * Indica se bisogna disegnare il trianogolo tagliato.
     */
    public boolean showRender = false;

    /**
     * Lista che contiene le aree dei triangoli che formano il fiocco.
     */
    public ArrayList<Shape> fiocco = new ArrayList<>();

    /**
     * Colore del triangolo.
     */
    private Color colorTriangolo = Color.WHITE;

    /**
     * Ritorna la lista con le aree del fiocco.
     *
     * @return lista di aree.
     */
    public ArrayList<Shape> getFiocco() {
        return fiocco;
    }

    /**
     * Setta un nuovo colore per il triangolo.
     *
     * @param triangolo
     */
    public void setColor(Color triangolo) {
        this.colorTriangolo = triangolo;
    }

    /**
     * Setta i poligoni di taglio letti da un file csv.
     *
     * @param poligoni di taglio salvati.
     */
    public void setPoligoni(ArrayList<Polygon> poligoni) {
        taglio.setPoligoni(poligoni);
    }

    /**
     * Creates new form Triangolo.
     */
    public TriangoloPanel() {
        initComponents();
        taglio.puntiPoligoni = new ArrayList<>();
        taglio.poligoni = new ArrayList<>();
        fiocco = new ArrayList<>();
        this.addMouseListener(this);
    }

    /**
     * Metodo che ridisgna i punti di taglio quando il panel viene
     * ridimensionato.
     */
    public void update() {
        if (!(getWidth() == lastWidth && getHeight() == lastHeight)) {
            taglio.changeCoords(getWidth() - lastWidth, getHeight() - lastHeight);
            lastWidth = getWidth();
            lastHeight = getHeight();
        }
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(0, 0, 102));
        setPreferredSize(new java.awt.Dimension(400, 200));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 349, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Si occupa di disegnare sul panel
     *
     * @param g é il contesto grafico.
     */
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        update();
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        triangolo.getTriangoloPoints(getWidth(), getHeight());

        if (!showRender) {

            g2.setColor(colorTriangolo);
            g2.fillPolygon(triangolo.getPolygon());

            g2.setColor(Color.ORANGE);

            if (taglio.puntiPoligoni.size() > 0) {
                Polygon temp = new Polygon();
                for (int i = 0; i < taglio.puntiPoligoni.size(); i++) {
                    temp.addPoint(taglio.puntiPoligoni.get(i).x, taglio.puntiPoligoni.get(i).y);
                }

                for (int i = 0; i < taglio.puntiPoligoni.size(); i++) {
                    g2.fillOval(taglio.puntiPoligoni.get(i).x - radius, taglio.puntiPoligoni.get(i).y - radius, radius * 2, radius * 2);
                    g2.fillPolygon(temp);

                }
            }

            g.setColor(Color.BLACK);
            for (int i = 0; i < taglio.poligoni.size(); i++) {
                for(int j = 0; j < taglio.poligoni.get(i).npoints;j++){
                    g2.fillPolygon(taglio.poligoni.get(i));
                    
                }
            }
        } else {
            g.setColor(colorTriangolo);
            triangoloTagliato = new TriangoloTagliato(triangolo.getPolygon(), taglio.poligoni);
            Area areaTaglio = triangoloTagliato.getAreaTagliato();
            g2.fill(areaTaglio);

            g.setColor(Color.ORANGE);

            if (taglio.puntiPoligoni.size() > 0) {
                Polygon temp = new Polygon();
                for (int i = 0; i < taglio.puntiPoligoni.size(); i++) {
                    temp.addPoint(taglio.puntiPoligoni.get(i).x, taglio.puntiPoligoni.get(i).y);
                }
                
                for (int i = 0; i < taglio.puntiPoligoni.size(); i++) {
                    g2.fillOval(taglio.puntiPoligoni.get(i).x - radius, taglio.puntiPoligoni.get(i).y - radius, radius * 2, radius * 2);
                    g2.fillPolygon(temp);
                }
            }
        }

    }

    /**
     * Cancella tutti i poligoni di taglio esistenti.
     */
    public void resetPoints() {
        taglio.puntiPoligoni.clear();
        taglio.poligoni.clear();
        taglio.copiaPuntiPoligoni.clear();
        repaint();
    }

    /**
     * Aggiunge un nuovo poligono di taglio.
     */
    public void addPolygon() {
        poligono = new Polygon();
        for (int i = 0; i < taglio.puntiPoligoni.size(); i++) {
            poligono.addPoint(taglio.puntiPoligoni.get(i).x, taglio.puntiPoligoni.get(i).y);
        }
        taglio.poligoni.add(poligono);
        taglio.puntiPoligoni.clear();
        taglio.copiaPuntiPoligoni.clear();
        repaint();

    }

    /**
     * Rimuove l'ultimo punto del l'ultimo poligono di taglio.
     */
    public void removeLastPoint() {
        taglio.removeLastPoint();
        repaint();
    }

    /**
     * Si occupa di salvare i punti dei poligoni di taglio.
     */
    public void savePoint() {
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter("File csv (*.csv)", "csv");
        chooser.setFileFilter(filter);
        int returnVal = chooser.showSaveDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                FileWriter fw = new FileWriter(chooser.getSelectedFile() + ".csv");
                BufferedWriter bw = new BufferedWriter(fw);
                bw.write(salva.salvaPoints(taglio.poligoni));
                bw.close();
            } catch (IOException ex) {
                System.out.println("Impossibile salvare il file!!");
            }
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    /**
     * Metodo richiamato quando il muose viene premuto e rilasciato.
     *
     * @param e evento del mouse.
     */
    public void mouseReleased(MouseEvent e) {
        taglio.puntiPoligoni.add(e.getPoint());
        taglio.copiaPuntiPoligoni.add(e.getPoint());
        repaint();
    }

    @Override
    public void mouseEntered(MouseEvent e) {

    }

    @Override
    public void mouseExited(MouseEvent e) {

    }

    /**
     * Si occupa di specchiare un area e riportarla nella posizione originale.
     *
     * @param fiocco area da specchiare.
     * @return area specchiata.
     */
    public Shape mirrorTriangle(Area fiocco) {

        AffineTransform specchia = new AffineTransform();
        specchia.scale(-1, 1);

        AffineTransform toOrigin = new AffineTransform();
        toOrigin.translate(-(triangolo.getApiceTriangolo().x) * 2, 0);

        AffineTransform tot = new AffineTransform();

        tot.concatenate(specchia);
        tot.concatenate(toOrigin);

        return tot.createTransformedShape(fiocco);
    }

    /**
     * Si occupa di ruotare un area in base a un angolo dato.
     *
     * @param fiocco area da ruotare.
     * @param angolo di quanto si deve ruotare l'area.
     * @return area ruotata.
     */
    public Shape rotateTriangle(Shape fiocco, double angolo) {
        AffineTransform rotate = new AffineTransform();
        rotate.rotate(Math.toRadians(angolo), triangolo.getApiceTriangolo().x, triangolo.getApiceTriangolo().y);
        return rotate.createTransformedShape(fiocco);
    }

    /**
     * Genera il fiocco.
     *
     * @return fiocco completo
     */
    public ArrayList<Shape> generaFiocco() {
        triangoloTagliato = new TriangoloTagliato(triangolo.getPolygon(), taglio.poligoni);
        fiocco.clear();
        Area areaTaglio = triangoloTagliato.getAreaTagliato();
        for (int i = 0; i < 36; i += 6) {
            Shape flip = mirrorTriangle(areaTaglio);
            fiocco.add(rotateTriangle(flip, i * 10));
            fiocco.add(rotateTriangle(areaTaglio, i * 10));
        }
        return fiocco;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
